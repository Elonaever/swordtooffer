HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。
今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。
但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？
例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。
给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)


//隐含动态规划的题目，记住的不是直接的答案，而是用来判断当前和和最大值的辅助参数
//定义f(n)表示直到a[n]的最大值比较项,每次得到新的f(n)就与当前存到ret的最大值比较，如果f(n)大，则更新ert
//对于a[n]来说，如果f(n-1)<0,那么f(n-1)就是累赘，还不如a[n]单干，因此f(n)=a[n];
//如果f(n-1)>0,那么不妨把a[n]和f(n-1)加一起形成新的f(n)(这个f(n)至少比单独的a[n]大),因此f(n)=f(n-1)+a[n];

//总结 ret=max{f(n)=H(f(n-1))+a[n],ret};
//H(x) = {x,x>0   0,x<=0}

class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
    	int ret = array[0],fn = array[0];
    	for(int i =1;i<array.size();++i){    		
    		if(fn>0) fn+= array[i];
    		else fn=array[i];
    		if(fn>ret) ret = fn;
		}
		return ret;
    }
};
